<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vueSoundCode-nextTick</title>
    <url>/2020/06/18/vueSoundCode-nextTick/</url>
    <content><![CDATA[<h1 id="vue源码解读系列-nextTick"><a href="#vue源码解读系列-nextTick" class="headerlink" title="vue源码解读系列-nextTick"></a>vue源码解读系列-nextTick</h1><h2 id="nextTick的用法"><a href="#nextTick的用法" class="headerlink" title="nextTick的用法"></a>nextTick的用法</h2><p>  依据vue官网中的教程而言，nextTick这个函数作用为：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。也就是说在当次事件循环中执行异步操作的回调函数中插入nextTick中的回调，并获取更新后的DOM。一般用来执行数据更新视图的操作。</p>
<a id="more"></a>  
<p>  一般用法：<br>  <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">html部分：</span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="line">js部分：</span><br><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#example'</span>,</span><br><span class="line">    dat<span class="variable">a:</span> &#123;</span><br><span class="line">    message: <span class="string">'123'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">vm</span>.message = <span class="string">'new message'</span> // 更改数据</span><br><span class="line"><span class="keyword">vm</span>.$<span class="keyword">el</span>.textContent === <span class="string">'new message'</span> // false</span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line"><span class="keyword">vm</span>.$<span class="keyword">el</span>.textContent === <span class="string">'new message'</span> // true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="nextTick源码解读"><a href="#nextTick源码解读" class="headerlink" title="nextTick源码解读"></a>nextTick源码解读</h2><p>  以下根据nextTick的源码中的方法逐个分析。</p>
<p>  函数<code>nextTickHandler</code>是nextTick中执行回调函数的操作，把回调<br>  队列中的回调函数依次执行。<br>  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> <span class="params">()</span> &#123; //依次把回调队列中的回调函数执行</span></span><br><span class="line">  pending = <span class="built_in">false</span>;</span><br><span class="line">  var copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">  callbacks.<span class="built_in">length</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; copies.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    copies[<span class="built_in">i</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  下面是vue中的nextTick的方法全部源码，已经在关键代码处写了注释说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callbacks = [];   <span class="comment">//声明一个回调函数队列</span></span><br><span class="line">  <span class="keyword">var</span> pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> timerFunc;    <span class="comment">//声明一个函数名</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123; <span class="comment">//依次把回调队列中的回调函数执行</span></span><br><span class="line">    pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">    callbacks.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      copies[i]();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An asynchronous deferring mechanism.</span></span><br><span class="line">  <span class="comment">// 异步延迟机制</span></span><br><span class="line">  <span class="comment">// In pre 2.4, we used to use microtasks (Promise/MutationObserver)</span></span><br><span class="line">  <span class="comment">// 在vue的 2.4版本前，我们常常使用微任务(Promise/MutationObserver)</span></span><br><span class="line">  <span class="comment">// but microtasks actually has too high a priority and fires in between</span></span><br><span class="line">  <span class="comment">// 但是实际上微任务有着很高的优先级而且在顺序事件甚至在冒泡事件中触发。</span></span><br><span class="line">  <span class="comment">// supposedly sequential events (e.g. #4521, #6690) or even between</span></span><br><span class="line">  <span class="comment">// bubbling of the same event (#6566). Technically setImmediate should be</span></span><br><span class="line">  <span class="comment">// 从技术上来说， setImmediate应该是一个理想的选择。</span></span><br><span class="line">  <span class="comment">// the ideal choice, but it's not available everywhere; and the only polyfill</span></span><br><span class="line">  <span class="comment">// 但是它也不适用于所有的地方；</span></span><br><span class="line">  <span class="comment">// that consistently queues the callback after all DOM events triggered in the</span></span><br><span class="line">  <span class="comment">// same loop is by using MessageChannel.</span></span><br><span class="line">  <span class="comment">// 在同一个事件循环中，在一段完整的回调函数队列被MessageChannel方法所触发的全部DOM事件之后，</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。以下是 setImmediate、MessageChannel、Promise、setTimeout四种情况进行分析*/</span></span><br><span class="line">  <span class="comment">// 判断setImmediate方法是否存在且为本地函数，如果符合判断则执行setImmediate方法，其余三种判断同理</span></span><br><span class="line">  <span class="comment">// setImmediate用法：把一些执行时间长的操作放到该回调函数中，当浏览器执行完后序操作后就立刻执行该函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">    timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setImmediate(nextTickHandler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// 如果满足消息通道的情形</span></span><br><span class="line">    <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel(); <span class="comment">//声明一个消息通道对象</span></span><br><span class="line">    <span class="keyword">var</span> port = channel.port2;</span><br><span class="line">    channel.port1.onmessage = nextTickHandler; <span class="comment">//监听回调函数</span></span><br><span class="line">    timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      port.postMessage(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="comment">// 满足promise的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="comment">// use microtask in non-DOM environments, e.g. Weex</span></span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      p.then(nextTickHandler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      &lt;!-- 最后如果<span class="built_in">Promise</span>.then 和 MessageChannel，如果执行环境不支持，则调用setTimeout --&gt;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(nextTickHandler, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 返回一个方法，该方法接受外部传进来回调函数和上下文 --&gt;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _resolve;</span><br><span class="line">    callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(ctx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, ctx, <span class="string">'nextTick'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 闭包，pending的作用为：限制同样的回调函数多次重复调用，如果同一个 watcher 被多次触发，只会被推入到队列中一次。</span></span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span>;</span><br><span class="line">      timerFunc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $flow-disable-</span></span><br><span class="line">    &lt;!-- <span class="number">2.1</span><span class="number">.0</span> 起新增：如果没有提供回调且在支持 <span class="built_in">Promise</span> 的环境中，则返回一个 <span class="built_in">Promise</span>。 --&gt;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        _resolve = resolve;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JSseries-async</title>
    <url>/2020/06/16/JSseries-async/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–Js的异步机制"><a href="#JS基本概念系列–Js的异步机制" class="headerlink" title="JS基本概念系列–Js的异步机制"></a>JS基本概念系列–Js的异步机制</h1><h2 id="js在浏览器中的运行机制"><a href="#js在浏览器中的运行机制" class="headerlink" title="js在浏览器中的运行机制"></a>js在浏览器中的运行机制</h2><p>  js一般运行在浏览器中，而浏览器有多个常驻线程：<br>  1.渲染引擎线程<br>  2.js引擎线程<br>  3.异步http请求线程</p>
<a id="more"></a>  
<p>  4.事件触发线程<br>  5.定时器触发线程<br>  由于js是运行在js引擎线程之上，而且在js引擎线程运行的时候，渲染引擎线程是被挂起的。因为js引擎线程是可以直接操作DOM的，而如果在渲染引擎线程工作的时候js引擎操作DOM，就会造成DOM混乱，所以这两者某个时间只能运行一个，另一个就要被挂起。</p>
<h2 id="同步任务、异步任务"><a href="#同步任务、异步任务" class="headerlink" title="同步任务、异步任务"></a>同步任务、异步任务</h2><p>  同步任务：如果这个函数返回的值，能够立刻被得到或者预测到。<br>  <strong>如果是同步函数，即使函数运行比较耗时，还是会等待到执行完毕</strong></p>
<p>  异步任务：函数返回时，调用者不能立刻得到结果，必须通过一些手段得到。</p>
<h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h2><p>  js在浏览器运行时，主要有几部分。一个是执行同步任务的主线程–执行栈，还有消息队列。其中异步任务又可细分为宏任务和微任务。这两者分别存储在对应的异步任务队列里面。<br>  宏任务：settimeout、setinternal、整段js代码、io操作、dom操作<br>  微任务：promise、process.nextTick</p>
<p>  具体执行过程大致为：首先当执行一段代码时，就相当于开始执行一个异步任务(该任务为一整段js代码)，在执行的过程中，如果遇到同步代码段，会直接放到执行栈中执行。而如果遇到异步任务，则会新开对应的线程执行该异步任务(见上文的浏览器线程)可直接执行的部分。同时把执行状态和回调函数放到对应的消息队列中，当这段代码执行完后，主线程会去查看异步任务队列，如果微任务队列有任务，则把微任务队列清空(<strong>这也是为什么微任务能插队宏任务的原因</strong>)。清空之后，继续执行下一个异步宏任务。可以说，宏任务和微任务执行关系是：每执行一个宏任务就要清空微任务队列。</p>
<p>  <img src="https://user-gold-cdn.xitu.io/2018/1/26/161314dcb17a84ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title="执行示例"></p>
<p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8" target="_blank" rel="noopener">参考引用:</a></p>
]]></content>
  </entry>
  <entry>
    <title>JSseries-Econtext</title>
    <url>/2020/06/10/JSseries-Econtext/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–作用域"><a href="#JS基本概念系列–作用域" class="headerlink" title="JS基本概念系列–作用域"></a>JS基本概念系列–作用域</h1><h2 id="作用域的原理和介绍"><a href="#作用域的原理和介绍" class="headerlink" title="作用域的原理和介绍"></a>作用域的原理和介绍</h2><p>执行环境(Execution Context)是JavaScript中最为重要的概念，一般当进入一段代码或者一个函数中时，就标志着进入了某个执行环境。而且每个执行环境都包含有一个变量对象(variable object),该执行环境中的所有对象和函数都被囊括在里面。</p>
<a id="more"></a>
<p>每个函数也有着自己的执行环境，随着函数的调用，该函数的执行环境会被推入一个环境栈之中，当该函数被调用完毕，环境栈就会把它推出来，这个时候这个执行环境就会被销毁。函数的执行环境中把活动对象(activity object)当做变量对象。</p>
<p>在一个被执行的执行环境中，变量对象存在一条作用域链(scope chain),当前的变量对象始终是该条作用域链的起点。同时作用域链只允许从当前执行环境向父执行环境搜索，直至到全局变量，不允许反向。这也是闭包能实现的原理之一。</p>
<p>浏览器中，会把全局的执行环境视为Windows对象。当某个环境被销毁时，其内的变量对象也会被销毁。全局执行环境中的变量对象始终是作用域链的终点。</p>
<h2 id="let块级作用域"><a href="#let块级作用域" class="headerlink" title="let块级作用域"></a>let块级作用域</h2><p>js中不存在块级作用域，由上可知只存在函数作用域或者全局作用域。而es6引入的let赋予了这一效果。而var声明会被自动添加到最近的作用域之中。</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>js中有两种方式可以延长作用域长度：with和try catch中的catch块。其中with()中的参数是某个变量对象，它会被添加到作用域链的前端。catch块会创建一个新的变量对象，把抛出的错误对象声明包含进去。</p>
]]></content>
  </entry>
  <entry>
    <title>JSseries_prototype</title>
    <url>/2020/06/08/JSseries-prototype/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–原型链和继承方式"><a href="#JS基本概念系列–原型链和继承方式" class="headerlink" title="JS基本概念系列–原型链和继承方式"></a>JS基本概念系列–原型链和继承方式</h1><h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><h4 id="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"><a href="#在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。" class="headerlink" title="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"></a>在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。</h4><a id="more"></a>

<h4 id="该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。"><a href="#该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。" class="headerlink" title="该构造函数的实例被创立时就会包含一个指针(内部属性)，指向这个构造函数的原型，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。"></a>该构造函数的实例被创立时就会包含一个指针(内部属性)，指向<strong>这个构造函数的原型</strong>，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。</h4><h2 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h2><h4 id="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"><a href="#假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。" class="headerlink" title="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"></a>假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。</h4><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><h4 id="通过原型链的原理继承超类型的原型上的方法。"><a href="#通过原型链的原理继承超类型的原型上的方法。" class="headerlink" title="通过原型链的原理继承超类型的原型上的方法。"></a>通过原型链的原理继承超类型的原型上的方法。</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码
SubType.prototype = new SuperType();   </code></pre><h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h3><h4 id="继承的是构造函数自身的属性"><a href="#继承的是构造函数自身的属性" class="headerlink" title="继承的是构造函数自身的属性"></a>继承的是构造函数自身的属性</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性方法 --&gt;
    SuperType.call(this);
}   </code></pre><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><h4 id="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"><a href="#通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。" class="headerlink" title="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"></a>通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
}        
//继承SuperType的原型属性方法
SubType.prototype = new SuperType();</code></pre><h3 id="4-寄生继承"><a href="#4-寄生继承" class="headerlink" title="4. 寄生继承"></a>4. 寄生继承</h3><h4 id="主要针对的是对象的继承，而不是自定义对象和构造函数"><a href="#主要针对的是对象的继承，而不是自定义对象和构造函数" class="headerlink" title="主要针对的是对象的继承，而不是自定义对象和构造函数"></a>主要针对的是对象的继承，而不是自定义对象和构造函数</h4><h4 id="object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"><a href="#object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现" class="headerlink" title="object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"></a>object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现</h4><pre><code>object(val) {
    function F() {};
    F.prototype = val;
    return new F();
}</code></pre><h4 id="寄生继承："><a href="#寄生继承：" class="headerlink" title="寄生继承："></a>寄生继承：</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype);   </code></pre><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><h4 id="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"><a href="#本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式" class="headerlink" title="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"></a>本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype); </code></pre>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
