<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JSseries_prototype</title>
    <url>/2020/06/08/JSseries-prototype/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–原型链和继承方式"><a href="#JS基本概念系列–原型链和继承方式" class="headerlink" title="JS基本概念系列–原型链和继承方式"></a>JS基本概念系列–原型链和继承方式</h1><h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><h3 id="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"><a href="#在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。" class="headerlink" title="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"></a>在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。</h3><h3 id="该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。"><a href="#该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。" class="headerlink" title="该构造函数的实例被创立时就会包含一个指针(内部属性)，指向这个构造函数的原型，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。"></a>该构造函数的实例被创立时就会包含一个指针(内部属性)，指向<strong>这个构造函数的原型</strong>，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。</h3><h2 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h2><h3 id="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"><a href="#假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。" class="headerlink" title="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"></a>假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。</h3><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><h3 id="通过原型链的原理继承超类型的原型上的方法。"><a href="#通过原型链的原理继承超类型的原型上的方法。" class="headerlink" title="通过原型链的原理继承超类型的原型上的方法。"></a>通过原型链的原理继承超类型的原型上的方法。</h3><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码
SubType.prototype = new SuperType();   </code></pre><h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h3><h3 id="继承的是构造函数自身的属性"><a href="#继承的是构造函数自身的属性" class="headerlink" title="继承的是构造函数自身的属性"></a>继承的是构造函数自身的属性</h3><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性方法 --&gt;
    SuperType.call(this);
}   </code></pre><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><h3 id="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"><a href="#通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。" class="headerlink" title="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"></a>通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。</h3><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
}        
//继承SuperType的原型属性方法
SubType.prototype = new SuperType();</code></pre><h3 id="4-寄生继承"><a href="#4-寄生继承" class="headerlink" title="4. 寄生继承"></a>4. 寄生继承</h3><h3 id="主要针对的是对象的继承，而不是自定义对象和构造函数"><a href="#主要针对的是对象的继承，而不是自定义对象和构造函数" class="headerlink" title="主要针对的是对象的继承，而不是自定义对象和构造函数"></a>主要针对的是对象的继承，而不是自定义对象和构造函数</h3><h3 id="object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"><a href="#object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现" class="headerlink" title="object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"></a>object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现</h3><pre><code>object(val) {
    function F() {};
    F.prototype = val;
    return new F();
}</code></pre><h3 id="寄生继承："><a href="#寄生继承：" class="headerlink" title="寄生继承："></a>寄生继承：</h3><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype);   </code></pre><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><h3 id="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"><a href="#本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式" class="headerlink" title="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"></a>本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式</h3><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype); </code></pre>]]></content>
  </entry>
  <entry>
    <title>Js高程3学习笔记-对象</title>
    <url>/2019/12/29/Js%E9%AB%98%E7%A8%8B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>来测试一下，预约一下位置</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>书本</tag>
      </tags>
  </entry>
  <entry>
    <title>first_Markdown</title>
    <url>/2019/12/17/first-Markdown/</url>
    <content><![CDATA[<p>![]</p>
]]></content>
      <categories>
        <category>-categorie1</category>
      </categories>
      <tags>
        <tag>-Tags1</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
