<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JSseries-async</title>
    <url>/2020/06/16/JSseries-async/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–Js的异步机制"><a href="#JS基本概念系列–Js的异步机制" class="headerlink" title="JS基本概念系列–Js的异步机制"></a>JS基本概念系列–Js的异步机制</h1><h2 id="js在浏览器中的运行机制"><a href="#js在浏览器中的运行机制" class="headerlink" title="js在浏览器中的运行机制"></a>js在浏览器中的运行机制</h2><p>  js一般运行在浏览器中，而浏览器有多个常驻线程：<br>  1.渲染引擎线程<br>  2.js引擎线程<br>  3.异步http请求线程</p>
<a id="more"></a>  
<p>  4.事件触发线程<br>  5.定时器触发线程<br>  由于js是运行在js引擎线程之上，而且在js引擎线程运行的时候，渲染引擎线程是被挂起的。因为js引擎线程是可以直接操作DOM的，而如果在渲染引擎线程工作的时候js引擎操作DOM，就会造成DOM混乱，所以这两者某个时间只能运行一个，另一个就要被挂起。</p>
<h2 id="同步任务、异步任务"><a href="#同步任务、异步任务" class="headerlink" title="同步任务、异步任务"></a>同步任务、异步任务</h2><p>  同步任务：如果这个函数返回的值，能够立刻被得到或者预测到。<br>  <strong>如果是同步函数，即使函数运行比较耗时，还是会等待到执行完毕</strong></p>
<p>  异步任务：函数返回时，调用者不能立刻得到结果，必须通过一些手段得到。</p>
<h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h2><p>  js在浏览器运行时，主要有几部分。一个是执行同步任务的主线程–执行栈，还有消息队列。其中异步任务又可细分为宏任务和微任务。这两者分别存储在对应的异步任务队列里面。<br>  宏任务：settimeout、setinternal、整段js代码、io操作、dom操作<br>  微任务：promise、process.nextTick</p>
<p>  具体执行过程大致为：首先当执行一段代码时，就相当于开始执行一个异步任务(该任务为一整段js代码)，在执行的过程中，如果遇到同步代码段，会直接放到执行栈中执行。而如果遇到异步任务，则会新开对应的线程执行该异步任务(见上文的浏览器线程)可直接执行的部分。同时把执行状态和回调函数放到对应的消息队列中，当这段代码执行完后，主线程会去查看异步任务队列，如果微任务队列有任务，则把微任务队列清空(<strong>这也是为什么微任务能插队宏任务的原因</strong>)。清空之后，继续执行下一个异步宏任务。可以说，宏任务和微任务执行关系是：每执行一个宏任务就要清空微任务队列。</p>
<p>  <img src="https://user-gold-cdn.xitu.io/2018/1/26/161314dcb17a84ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title="执行示例"></p>
<p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8" target="_blank" rel="noopener">参考引用:</a></p>
]]></content>
  </entry>
  <entry>
    <title>JSseries-Econtext</title>
    <url>/2020/06/10/JSseries-Econtext/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–作用域"><a href="#JS基本概念系列–作用域" class="headerlink" title="JS基本概念系列–作用域"></a>JS基本概念系列–作用域</h1><a id="more"></a>

<h2 id="作用域的原理和介绍"><a href="#作用域的原理和介绍" class="headerlink" title="作用域的原理和介绍"></a>作用域的原理和介绍</h2><p>执行环境(Execution Context)是JavaScript中最为重要的概念，一般当进入一段代码或者一个函数中时，就标志着进入了某个执行环境。而且每个执行环境都包含有一个变量对象(variable object),该执行环境中的所有对象和函数都被囊括在里面。</p>
<p>每个函数也有着自己的执行环境，随着函数的调用，该函数的执行环境会被推入一个环境栈之中，当该函数被调用完毕，环境栈就会把它推出来，这个时候这个执行环境就会被销毁。函数的执行环境中把活动对象(activity object)当做变量对象。</p>
<p>在一个被执行的执行环境中，变量对象存在一条作用域链(scope chain),当前的变量对象始终是该条作用域链的起点。同时作用域链只允许从当前执行环境向父执行环境搜索，直至到全局变量，不允许反向。这也是闭包能实现的原理之一。</p>
<p>浏览器中，会把全局的执行环境视为Windows对象。当某个环境被销毁时，其内的变量对象也会被销毁。全局执行环境中的变量对象始终是作用域链的终点。</p>
<h2 id="let块级作用域"><a href="#let块级作用域" class="headerlink" title="let块级作用域"></a>let块级作用域</h2><p>js中不存在块级作用域，由上可知只存在函数作用域或者全局作用域。而es6引入的let赋予了这一效果。而var声明会被自动添加到最近的作用域之中。</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>js中有两种方式可以延长作用域长度：with和try catch中的catch块。其中with()中的参数是某个变量对象，它会被添加到作用域链的前端。catch块会创建一个新的变量对象，把抛出的错误对象声明包含进去。</p>
]]></content>
  </entry>
  <entry>
    <title>JSseries_prototype</title>
    <url>/2020/06/08/JSseries-prototype/</url>
    <content><![CDATA[<h1 id="JS基本概念系列–原型链和继承方式"><a href="#JS基本概念系列–原型链和继承方式" class="headerlink" title="JS基本概念系列–原型链和继承方式"></a>JS基本概念系列–原型链和继承方式</h1><h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><h4 id="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"><a href="#在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型-prototype-。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。" class="headerlink" title="在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。"></a>在js之中，每个构造函数都拥有一个名为prototype属性，它指向此构造函数创立之初就被js赋予的该构造函数的原型(prototype)。而在该原型对象中存在一个名为constructor属性，指向它的构造函数。</h4><a id="more"></a>

<h4 id="该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。"><a href="#该构造函数的实例被创立时就会包含一个指针-内部属性-，指向这个构造函数的原型，在主流浏览器打印中一般用-Prototype-表示，但是不能直接访问。" class="headerlink" title="该构造函数的实例被创立时就会包含一个指针(内部属性)，指向这个构造函数的原型，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。"></a>该构造函数的实例被创立时就会包含一个指针(内部属性)，指向<strong>这个构造函数的原型</strong>，在主流浏览器打印中一般用[[Prototype]],表示，但是不能直接访问。</h4><h2 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h2><h4 id="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"><a href="#假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从-Prototype-指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。" class="headerlink" title="假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。"></a>假设有这种情况：一个构造函数的实例调用一个函数，但是该实例没有，这时js就会从[[Prototype]]指向的对象去找，这就找到了该构造函数的原型。如果这个原型对象也包含指向另一个原型对象的指针，那么将会继续向上找寻，层层递进。这就是原型链。</h4><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><h4 id="通过原型链的原理继承超类型的原型上的方法。"><a href="#通过原型链的原理继承超类型的原型上的方法。" class="headerlink" title="通过原型链的原理继承超类型的原型上的方法。"></a>通过原型链的原理继承超类型的原型上的方法。</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码
SubType.prototype = new SuperType();   </code></pre><h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h3><h4 id="继承的是构造函数自身的属性"><a href="#继承的是构造函数自身的属性" class="headerlink" title="继承的是构造函数自身的属性"></a>继承的是构造函数自身的属性</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性方法 --&gt;
    SuperType.call(this);
}   </code></pre><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><h4 id="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"><a href="#通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。" class="headerlink" title="通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。"></a>通过结合原型链和构造函数的形式组合继承超类自身属性和构造函数的原型上的方法。</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
}        
//继承SuperType的原型属性方法
SubType.prototype = new SuperType();</code></pre><h3 id="4-寄生继承"><a href="#4-寄生继承" class="headerlink" title="4. 寄生继承"></a>4. 寄生继承</h3><h4 id="主要针对的是对象的继承，而不是自定义对象和构造函数"><a href="#主要针对的是对象的继承，而不是自定义对象和构造函数" class="headerlink" title="主要针对的是对象的继承，而不是自定义对象和构造函数"></a>主要针对的是对象的继承，而不是自定义对象和构造函数</h4><h4 id="object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"><a href="#object-create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现" class="headerlink" title="object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现"></a>object.create的实现主要为：创建一个新的构造函数，把传入的参数对象赋值给该构造函数的原型，最后返回该构造函数的一个实例。下面以一个object函数实现</h4><pre><code>object(val) {
    function F() {};
    F.prototype = val;
    return new F();
}</code></pre><h4 id="寄生继承："><a href="#寄生继承：" class="headerlink" title="寄生继承："></a>寄生继承：</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype);   </code></pre><h3 id="5-寄生组合继承"><a href="#5-寄生组合继承" class="headerlink" title="5. 寄生组合继承"></a>5. 寄生组合继承</h3><h4 id="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"><a href="#本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式" class="headerlink" title="本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式"></a>本质上是组合继承，只是把组合继承中的原型链方式由借用实例生成的方式变为寄生方式</h4><pre><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function SubType() {
    &lt;!-- 继承SuperType属性 --&gt;
    SuperType.call(this);
    this.subproterty = false;
}

//关键代码,实现寄生继承
SubType.prototype = object(SuperType.prototype); </code></pre>]]></content>
  </entry>
  <entry>
    <title>Js高程3学习笔记-对象</title>
    <url>/2019/12/29/Js%E9%AB%98%E7%A8%8B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>来测试一下，预约一下位置</p>
]]></content>
      <tags>
        <tag>学习</tag>
        <tag>书本</tag>
      </tags>
  </entry>
  <entry>
    <title>first_Markdown</title>
    <url>/2019/12/17/first-Markdown/</url>
    <content><![CDATA[<p>![]</p>
]]></content>
      <categories>
        <category>-categorie1</category>
      </categories>
      <tags>
        <tag>-Tags1</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
